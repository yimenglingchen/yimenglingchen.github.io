---

layout: post

title:  maven杂谈

tag: CICD

---
# maven杂谈

## 1、maven中的scope

​	scope在maven的依赖管理中主要负责项目的部署，maven中，scope的默认值是compile。

### 1.1、scope的分类

1. compile：默认值 他表示被依赖项目需要参与当前项目的编译，还有后续的测试，运行周期也参与其中，是一个比较强的依赖。打包的时候通常需要包含进去
2. test：依赖项目仅仅参与测试相关的工作，包括测试代码的编译和执行，不会被打包，例如：junit

3. runtime：表示被依赖项目无需参与项目的编译，不过后期的测试和运行周期需要其参与。与compile相比，跳过了编译而已。例如JDBC驱动，适用运行和测试阶段

4. provided：打包的时候可以不用包进去，别的设施会提供。事实上该依赖理论上可以参与编译，测试，运行等周期。相当于compile，但是打包阶段做了exclude操作

5. system：从参与度来说，和provided相同，不过被依赖项不会从maven仓库下载，而是从本地文件系统拿。需要添加systemPath的属性来定义路径

### 1.2、依赖传递

​	A依赖B，B依赖C。当前项目为A，只当B在A项目中的scope，那么c在A中的scope是如何得知呢？

​	当C是test或者provided时，C直接被丢弃，A不依赖C；（排除传递依赖）

​	否则A依赖C，C的scope继承与B的scope。

## 2、maven中的快照

### 	2.1、什么是快照

​		快照是一种特殊的版本，指定了某个当前的开发进度的副本。不同于常规的版本，Maven 每次构建都会在远程仓库中检查新的快照。

### 	1.2、解决了什么问题

​		个大型的软件应用通常包含多个模块，并且通常的场景是多个团队开发同一应用的不同模块。举个例子，设想一个团队开发应用的前端，项目为 app-ui(app-ui.jar:1.0)，而另一个团队开发应用的后台，使用的项目是 data-service(data-service.jar:1.0)。

​		现在可能出现的情况是开发 data-service 的团队正在进行快节奏的 bug 修复或者项目改进，并且他们几乎每隔一天就要发布库到远程仓库。 现在如果 data-service 团队每隔一天上传一个新版本，那么将会出现下面的问题：

- data-service 团队每次发布更新的代码时都要告知 app-ui 团队。
- app-ui 团队需要经常地更新他们 pom.xml 文件到最新版本。

### 1.3、maven对于快照的策略

​		快照（SNAPSHOT）在maven中就是不稳定版本的意思，每次构建的时候，maven都会从仓库中自动获取最新的快照版本。

## 3、maven中的依赖管理

​	当maven处理多模块项目的时候，模块间的依赖关系就会非常复杂，maven提供了一种策略来进行模块依赖管理。

​	maven支持依赖传递，当出现依赖传递的时候，很容易出现依赖冲突，maven提供了很多策略来防止出现冲突。

| 功能     | 功能描述                                                     |
| :------- | :----------------------------------------------------------- |
| 依赖调节 | 决定当多个手动创建的版本同时出现时，哪个依赖版本将会被使用。 如果两个依赖版本在依赖树里的深度是一样的时候，第一个被声明的依赖将会被使用。 |
| 依赖管理 | 直接的指定手动创建的某个版本被使用。例如当一个工程 C 在自己的依赖管理模块包含工程 B，即 B 依赖于 A， 那么 A 即可指定在 B 被引用时所使用的版本。 |
| 依赖范围 | 包含在构建过程每个阶段的依赖。                               |
| 依赖排除 | 任何可传递的依赖都可以通过 "exclusion" 元素被排除在外。举例说明，A 依赖 B， B 依赖 C，因此 A 可以标记 C 为 "被排除的"。 |
| 依赖可选 | 任何可传递的依赖可以被标记为可选的，通过使用 "optional" 元素。例如：A 依赖 B， B 依赖 C。因此，B 可以标记 C 为可选的， 这样 A 就可以不再使用 C。 |

​	也可以通过scope来进行控制。

对于组件依赖版本冲突，推荐建立父级POM进行版本统一管理，各个组件按需引入，不在定义版本。

## 4、maven和gradle对于依赖冲突的区别

   先说什么是依赖冲入，假设现在开发的项目，应用了fastJson的依赖，版本是1.2.58，引用的另一个依赖中同样应用了fastJson，版本是1.2.57 这样就会有版本冲突，maven判断依据是远近，或者是依赖覆盖，当前引用覆盖依赖中的引用，对于gradle来讲，是版本覆盖，高版本覆盖低版本。