---

layout: post

title: 一文了解JVM-（1、内存区域划分和对象）

tag: java语言

---
# 一文了解JVM-（1、内存区域划分和对象）

## 1、前言

本篇博客重点讲的是java中的内存模型，回收算法相关内容。

## 2、运行时内存区域和内存溢出异常

​	java虚拟机在执行java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机的启动而存在，有的区域则需要依赖用户线程的启动和结束进行建立和销毁，根据java虚拟机规范，java虚拟机所管理的内存将会包括以下几个运行时数据区域

1. 程序计数器 线程隔离

2. 方法区 所有线程共享

3. 堆 所有线程共享

4. 虚拟机栈 线程隔离

5. 本地方法栈  线程隔离

   

逐一介绍
### 2.1、程序计数器

​	程序计数器是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器，在虚拟机的状态模型中，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成。

​	由于java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令，因此，为了线程切换后能够恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各个线程之间的计数器互不影响，独立存储，我们称这类内存区域为线程私有的内存。

​	如果线程正在执行的是一个java方法，这个计数器记录的是这个正在执行的虚拟机字节码指令的地址，如果正在执行的是native方法，这个计数器值就是空的，次内存区域是唯一一个在虚拟机规范中没有规定任何OOME情况的区域。

### 2.2、java虚拟机栈

​	和程序计数器一样，java虚拟机栈也是线程私有的，声明周期和线程一直，虚拟机栈描述的是java方法执行的内存模型，每一个方法在执行的同时都会创造一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等，每一个方法从调用到执行完成的过程，就对应了一个栈帧在虚拟机栈中的入栈到出栈的过程。

​	局部变量表存放了编译器可以知道的各种基本的数据类型，对象引用和returnaddress类型。其中，对于64位的long和double会占据2个局部变量空间，其余的数据类型只会占据一个，局部变量表的内存空间在编译期间完成分配，当进入一个方法的时候，这个方法需要在帧中分配多大的局部变量空间是完全确定的，再放放运行期间不会改变局部变量表的大小。

在java虚拟机规范中，对这片区域规定了两种异常情况，

1. 如果线程请求的栈的深度大于虚拟机所允许的深度，抛出StackOverflowError异常、
2. 如果虚拟机栈可以动态扩展，扩展的时候没有办法申请到足够的内存，就会抛出OutOfMemoryError。

### 2.3、本地方法栈

​	本地方法栈和虚拟机所发挥的作用是很相似的，它们之间的区别不过是虚拟机栈为虚拟机执行java方法服务，本地方法则是虚拟机使用到的native方法服务，在虚拟机规范中对本地方法栈中方法使用的语言，使用的方式，和数据结构并没有强制的规定，因此具体的虚拟机可以自由的实现它，本地方法去和虚拟机占一样，会抛出两种异常。

### 2.4、java堆

​	对于大多数应用来讲，java堆是java虚拟机所管理的内存中最大的一块，java堆是被所有线程共享的一块内存区域，在虚拟机启动的时候创建，此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都是在这里分配内存，在java虚拟机中的描述是这样的*所有对象实例以及数组都要在堆山分配，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配，标量替换优化技术将会导致一些微妙的变化发生，所有对象都分配在堆上也不是那么的绝对了*。

​	java堆是垃圾收集器的管理的主要区域，因此很多时间也被成为GC堆，从内存挥手的角度来讲，由于现代收集器采用分代收集算法，所以java堆中还可以细分为：新生代和老年代，再细致的划分新生代可以分为Edan区域，From Survivor区域，To Survivor空间，从内存分配的角度来看，线程共享堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer TLAB），无论哪个区域存放的都是对象实例，进一步的划分只是为了更好的进行内存回收。

对于这块内存来讲，如果堆中没有内存完成实例分配，并且堆没有办法再扩展的时候，就会抛出OOME。

### 2.5、方法区

​	方法区和java堆一样，是各个线程共享的内存区域，用于存储已经被虚拟机加载的类型新，常亮，静态变量，即时编译器编译后的代码等数据，虽然java虚拟机规范把方法区描述成堆中的一个逻辑部分，但是它有一个别名为非堆。
​	对于hotspot虚拟机，开发者更愿意把方法区称之为永久代，本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队把GC分代收集扩展到方法区，或者说使用永久代来实现了方法区。

​	java虚拟机对方法区的限制非常宽松，除了和java堆一样不需要连续和内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。这块区域的内存挥手目标主要是针对常量池的挥手和对类型的卸载，但是回收的条件比较苛刻。

### 2.6、运行时常量池

​	运行时常量池是方法区域的一部分，对于一个Class文件来讲，除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池，用于存放编译期间申城的各种字面量和符号引用，这部分内容将在类加载后进入方法区域的运行时常量池中存放。

### 2.7、直接内存

​	直接内存并不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域，但是这部分内存也会被频繁的使用，而且也可能导致OOME异常出现。

​	在jdk1.4的时候，加入了NIO类，引入了一种基于通道和缓冲区的IO方式，可以使用Native函数库直接分配对外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，这样能在一些场景中显著提高性能，因为避免了在java堆和native堆中往复复制数据。

## 3、HotSpot虚拟机中的对象

### 	3.1、一个对象的创建过程

​	java是一门面向对象的编程语言，java程序运行中无时无刻都有对象被创建出来，在语言层面上，闯进对象（克隆，反序列化）通常仅仅是一个new关键字，但是在虚拟机中，要经历很多的过程。

1. 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化，如果没有，则进行相应的类加载过程。
2. 类加载检查通过后，虚拟机会为新生对象分配内容，对象所需要内存的大小在类加载完成后便可以完全确定，所以，为对象分配内存等同于把一块确定大小的内存从java堆中划分出来。这时候出现了两个概念
   1. 建设java对中内存是绝对能够规整的，所有用过的内存都放在一边，空间的内容放在另一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅把指针向空闲的地方挪动一段位置即可，这种分配方式就是指针碰撞。
   2. 如果java堆中的内存不是规整的，已经使用的内存和空间的内存相互交错，那就没有办法简单的进行指针碰撞了，虚拟机就必须维护一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间分给对象实例，并且更新列表上的记录，这种分配方式成为空闲列表。
   3. 在分配的过程中为了保证对象在虚拟机中是线程安全的，同样有两种方式
      1. 虚拟机采用的策略是CAS配上失败重试的机制保证更新操作的原子性。
      2. 另一种是把内存分配的动作按照线程划分在不同的空间中进行，就是为没个线程在java堆中预先分配一小块内存，TLAB，哪个线程要分配内存，就在哪个线程的TLAB上进行分配。
3. 内存分配完成之后，虚拟机将分配到内存空间都初始化为零值，如果使用TLAB，这个工作过程也可以提前在TLAB分配的时候进行，这一步操作保证了对象的实例字段在java代码中可以不赋予初始值就可直接使用，程序能够访问到这些字段的数据类型对应的零值。
4. 虚拟机堆对象进行一些必要设置，比如对象是哪个类的实例，如何找到类的元数据信息，对象的哈希码，对象的GC分代年靓的给你信息，这些都会存放在对象的对象头中，根据虚拟机当前的状态的运行状态不容，是否启用偏向锁等，对象头会有不同的设置方式。
5. 虚拟机完成上面那些步骤，一个对象才算是创建完成，但从java程序的视觉来看，还需要执行init方法，按照程序员的意愿进程初始化。

### 3.2、对象的内存布局

​	在HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域

1. 对象头
2. 实例数据
3. 对其填充

对象头

​	HotSpot虚拟机中的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等，这部分数据的长度在32位或者64位的虚拟机中，因为对象要存储的运行时数据很多，超出了32位或者64位的限制，但是对象头信息和对象自身定义的数据无关，考虑到虚拟机的空间效率，这块被设计为一个非固定的数据结构为了在极小的数据空间中存储尽量多的信息，比如在32位的hotspot中，25bit用于存储对象的哈希码，4bit用作存储对象的分代年龄，2bit用作锁标志位，1bit位0，对象的另一部分是指针类型，对象指向它的类元数据的指针，虚拟机通过这个指针知道对象是哪一个类的实例，如果是一个java数组，对象头中还必须有一块用于记录数组长度的数据。

实例数据

​	实例数据是对象真正存储的有效信息，也是在程序代码中所定义的各种恶理性的字段内容，这部分的存储顺序会受到虚拟机分配策略参数和字段在java源码中定义的顺序的影响，hotspot分配策略是相同宽度的字段分配到一起，在这个条件下，父类定义的变量会出现在子类之前。

对齐填充

​	对齐填充不是必然存在的，也没有特别的含义，仅仅是起着占位符的作用，因为hotspot vm自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是说，对象的大小必须是8字节的整数倍、因此，对象实例数据没有对齐时，就需要通过对齐填充来补全。

### 3.3、对象的访问定位

​	java程序需要通过栈上的reference数据来操作堆上的具体对象，由于reference类型在java虚拟机规范中只定义了一个指向对象的引用，并没有定义这个引用应该通过什么方式去定位，访问堆中的对象具体位置，目前主流的访问方式有使用句柄和直接指针两种。	

1. 如果使用句柄访问的话，java堆中会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，句柄包含了对象实例数据和类型数据各自的具体地址信息，使用句柄访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动的时候只会改变句柄中的实例数据指针，reference本身不需要改变。
2. 如果使用直接指针访问，java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，使用直接指针访问方式的最大好处就是速度更快，节省了依次指针定位的时间开销，对象的访问在java中非常频繁，因此这类开销积少成多后也是一项粉刺昂客观的执行成本。





   

   

