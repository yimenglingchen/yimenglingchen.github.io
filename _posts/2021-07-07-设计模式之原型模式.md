---

layout: post

title:  设计模式之原型模式

tag: 设计模式

---

# 设计模式之原型模式

---

## 1 原型模式定义

```
原型模式的定义：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。

需要注意，不可以返回本实例，这样做每次克隆客户端获取的其实都是同一个实例，都是只想一个内存空间的，对克隆出来的对象实例的修改会影响到原型对象实例。
```

---

## 2 程序示例

首先声明一个克隆接口

```java
/**
 * 声明一个克隆自身的接口
 */
public interface Prototype {
    /**
     * 克隆自身的方法
     * @return 一个从自身克隆出来的对象
     */
    public Prototype clone();
}
```

实现克隆接口，为了简化不传入参数

```java
/**
 * 克隆的具体实现对象
 */
public class ConcretePrototype1 implements Prototype{
    @Override
    public Prototype clone() {
        //最简单的克隆，新建一个自身对象，由于没有属性，就不再赋值值了
        Prototype prototype = new ConcretePrototype1();
        return prototype;
    }
}

/**
 * 克隆的具体实现对象
 */
public class ConcretePrototype2 implements Prototype{
    @Override
    public Prototype clone() {
        //最简单的克隆，新建一个自身对象，由于没有属性，就不再赋值值了
        Prototype prototype = new ConcretePrototype2();
        return prototype;
    }
}
```

客户端调用，创建克隆对象

```java
/**
 * 使用原型的客户端
 */
public class Client {

    /**
     * 持有需要使用的原型接口对象
     */
    private Prototype prototype;

    /**
     * 构造方法，传入需要使用的原型接口对象
     * @param prototype 需要使用的原型接口对象
     */
    public Client (Prototype prototype) {
        this.prototype = prototype;
    }

    /**
     * 示意方法，执行某个功能操作
     */
    public void operation() {
        //需要创建原型接口的对象
        Prototype newPrototype = prototype.clone();
    }
}
```

---

## 3 克隆模式讲解

### 3.1 克隆模式的主要功能

原型模式的功能实际上包含两个方面：

一个是通过克隆来创建新的对象实例。

另一个是为克隆出来的新的对象实例复制原型实例属性的值。

原型模式要实现的主要功能就是：通过克隆来创建新的对象实例。

### 3.2 克隆模式的要点

克隆方法和new操作最明显的不同在于：new一个对象实例，一般属性是没有值的，或者是只有默认值；如果是克隆得到的一个实例，通常属性是有值的，属性的值就是原型对象实例在克隆的时候，原型对象实例的属性的值。

原型实例和克隆出来的实例，本质上是不同的实例。

### 3.3 克隆模式的Java方法

java代码可以实现Cloneable接口，并重写clone方法，如果只是基本的实现，直接super.clone()即可。

### 3.4 深度克隆和浅度克隆

浅度克隆：只负责克隆按值传递的数据。

深度克隆：除了浅度克隆要克隆的值外，还负责克隆引用类型的数据，基本上就是被克隆实例所有的属性数据都会被克隆出来。

深度克隆还有一个特点，如果被克隆的对象里面的属性数据是引用类型，则需要一直递归地克隆下去，这也意味着如果想深度克隆成功，必须要整个克隆所涉及的对象都要正确实现克隆方法。

用java实现Cloneable接口进行深度克隆时，需要手动给引用类型进行克隆后赋值，覆盖掉浅度克隆的数据。

### 3.5 原型模式的优缺点

#### 3.5.1 原型模式的优点

对客户端隐藏具体的实现类型，减少了客户端对具体实现类型的依赖。

在运行时动态改变具体的实现类型。

#### 3.5.2 原型模式的缺点

每个原型的子类都必须实现clone的操作，clone方法会比较麻烦，必须要能够递归地让所有的相关对象都要正确地实现克隆。

### 3.6 原型模式的本质

原型模式的本质：克隆生成对象。

### 3.7 何时采用原型模式

1.如果一个系统想要独立于它想要使用的对象时，可以使用原型模式，让系统只面向接口编程，在系统需要新的对象的时候，可以通过克隆原型来得到。

2.如果需要实例化的类是在运行时刻动态指定时，可以使用原型模式，通过克隆原型来得到需要的实例。