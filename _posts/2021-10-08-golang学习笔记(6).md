---

layout: post

title:  golang学习笔记(6)

tag: go语言

---

# golang学习笔记(6)

---

## 1 接口

### 1 声明

接口类型与其他类型不同，是没法被实例化的。更具体地说，我们没法通过调用new函数或make函数创建出一个接口类型的值，也没法用字面量来表达一个接口类型的值。

通过type和interface关键字，我们可以声明出接口类型，举例如下：

```go
type Fish interface {
    Name() String
    SetName(name String)
}
```

而任何数据类型，只要包含了一个接口中的全部特征（上述例子就是Name和SetName），那么它就是这个接口的实现类型。

这是一种无侵入式的接口实现方式，这种方式还有一个专属名词——“Duck typing”。

### 2 接口的值

一个接口的本身类型叫做静态类型，而当它被赋值的时候，这个类型就是动态类型，相当于被实现的这个数据类型的类型，随着被实现的数据类型而变化。此时接口的值也被称作动态值。

需要注意，go里的变量赋值都是浅拷贝，也就是说，赋值过去的并不是原本的值，而是一个副本，因此赋值之后，修改一方并不会影响到另一方的值。

除此之外，给接口赋值时，接口一旦实现了某个数据类型，那么它就不再是nil了。该变量的动态类型，会和它的动态值一起被存储到一个特定的数据结构iface中。

iface实例中会包含两个指针，一个指向动态类型信息，一个指向动态值。这里的类型信息指的是另一个专用数据结构来承载的。

因此，当我们给接口赋一个为nil的数据类型的时候，接口的值并不是nil，而是iface实例，实例中存储的是这个数据类型的动态类型和动态值。接口为nil只有两种可能：只声明且没有初始化，和直接赋值字面量nil。

### 3 接口的组合

接口类型之间也是可以相互组合的，示例如下：

```go
type Animal interface {
    ScientificName() string
    Category() string
}

type Pet interface {
    Animal
    Name() string
}
```

在上面的实例中，Animal接口在Pet中接口占一行，就表示Pet接口中包含了Animal的所有实现方法。通过这种方式，可以将接口进行便捷的拆分和组装。

我们可以编写若干个小接口，只定义每个操作的类型，然后将这些接口进行组装，实现部分操作，而不用冗余地编写打量相仿的接口。

这个操作有一点装饰模式的感觉，可以进行对照学习。

---

## 2 关于指针的有限操作

### 1 不可被寻址的值

&XXX，&符号是寻址表达式。

常量的值。

基本类型值的字面量。

算术操作的结果值。

对各种字面量的索引表达式和切片表达式的结果值。不过有一个例外，对切片字面量的索引结果值却是可寻址的。

对字符串变量的索引表达式和切片表达式的结果值。

对字典变量的索引表达式的结果值。

函数字面量和方法字面量，以及对它们的调用表达式的结果值。

结构体字面量的字段值，也就是对结构体字面量的选择表达式的结果值。

类型转换表达式的结果值。

类型断言表达式的结果值。

接收表达式的结果值。

代码示例（因为这个实在是难以理解和记忆，因此列出完整的代码）：

```go
package main

type Named interface {
	// Name 用于获取名字。
	Name() string
}

type Dog struct {
	name string
}

func (dog *Dog) SetName(name string) {
	dog.name = name
}

func (dog Dog) Name() string {
	return dog.name
}

func main() {
	// 示例1。
	const num = 123
	//_ = &num // 常量不可寻址。
	//_ = &(123) // 基本类型值的字面量不可寻址。

	var str = "abc"
	_ = str
	//_ = &(str[0]) // 对字符串变量的索引结果值不可寻址。
	//_ = &(str[0:2]) // 对字符串变量的切片结果值不可寻址。
	str2 := str[0]
	_ = &str2 // 但这样的寻址就是合法的。

	//_ = &(123 + 456) // 算术操作的结果值不可寻址。
	num2 := 456
	_ = num2
	//_ = &(num + num2) // 算术操作的结果值不可寻址。

	//_ = &([3]int{1, 2, 3}[0]) // 对数组字面量的索引结果值不可寻址。
	//_ = &([3]int{1, 2, 3}[0:2]) // 对数组字面量的切片结果值不可寻址。
	_ = &([]int{1, 2, 3}[0]) // 对切片字面量的索引结果值却是可寻址的。
	//_ = &([]int{1, 2, 3}[0:2]) // 对切片字面量的切片结果值不可寻址。
	//_ = &(map[int]string{1: "a"}[0]) // 对字典字面量的索引结果值不可寻址。

	var map1 = map[int]string{1: "a", 2: "b", 3: "c"}
	_ = map1
	//_ = &(map1[2]) // 对字典变量的索引结果值不可寻址。

	//_ = &(func(x, y int) int {
	//	return x + y
	//}) // 字面量代表的函数不可寻址。
	//_ = &(fmt.Sprintf) // 标识符代表的函数不可寻址。
	//_ = &(fmt.Sprintln("abc")) // 对函数的调用结果值不可寻址。

	dog := Dog{"little pig"}
	_ = dog
	//_ = &(dog.Name) // 标识符代表的函数不可寻址。
	//_ = &(dog.Name()) // 对方法的调用结果值不可寻址。

	//_ = &(Dog{"little pig"}.name) // 结构体字面量的字段不可寻址。

	//_ = &(interface{}(dog)) // 类型转换表达式的结果值不可寻址。
	dogI := interface{}(dog)
	_ = dogI
	//_ = &(dogI.(Named)) // 类型断言表达式的结果值不可寻址。
	named := dogI.(Named)
	_ = named
	//_ = &(named.(Dog)) // 类型断言表达式的结果值不可寻址。

	var chan1 = make(chan int, 1)
	chan1 <- 1
	//_ = &(<-chan1) // 接收表达式的结果值不可寻址。

}
```

另外，可以通过unsafe.Pointer来直接操作指针，且在unsafe包下有很多相关的操作，但由于是非安全，非常规情况下不建议使用。

