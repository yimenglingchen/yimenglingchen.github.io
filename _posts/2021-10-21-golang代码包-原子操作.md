---

layout: post

title:  golang代码包-原子操作

tag: go语言

---

# golang代码包-原子操作

---

## 1 前导

Go语言运行时系统的调度器会恰当安排goroutine的执行顺序，也就是换上和换下的操作。这个暂停和启用goroutine没有规律，为了避免某些场景被打断，就需要原子性的操作。

真正能够保证原子性执行的只有原子性操作，原子操作在执行的过程中是不允许被中断的。

原子操作很少，原子操作的函数都在sync/atomic包中。

sync/atomic包中的函数可以做的原子操作有：加法（add）、比较并交换（compare and swap，简称 CAS）、加载（load）、存储（store）和交换（swap）。

此外，sync/atomic包还提供了一个名为Value的类型，它可以被用来存储任意类型的值。

原子操作函数需要的是被操作值的指针，而不是这个值本身。

当然，减法同样也可以通过加上负数来处理，如果遇到uint32这种没符号的类型，只需要做一下类型转换即可。

```go
    // 第二个衍生问题的示例。
    num := uint32(18)
    fmt.Printf("The number: %d\n", num)
    delta := int32(-3)
    atomic.AddUint32(&num, uint32(delta))
    fmt.Printf("The number: %d\n", num)
    atomic.AddUint32(&num, ^uint32(-(-3)-1))
    fmt.Printf("The number: %d\n", num)
    
    fmt.Printf("The two's complement of %d: %b\n",
        delta, uint32(delta)) // -3的补码。
    fmt.Printf("The equivalent: %b\n", ^uint32(-(-3)-1)) // 与-3的补码相同。
    fmt.Println()
```

